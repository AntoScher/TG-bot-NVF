: TG-bot-NVF ├── .venv # Виртуальная среда ├── api # Директория для API │ ├── news_api.py # API для новостей │ ├── photo_api.py # API для фотографий │ └── video_api.py # API для видео ├── handlers # Директория для обработчиков │ ├── news.py # Обработка новостей │ ├── photo.py # Обработка фотографий │ ├── start.py # Обработка команды старта │ └── video.py # Обработка видео ├── .env # Файл окружения ├── .gitattributes # Git атрибуты ├── .gitignore # Игнорируемые файлы Git ├── bot.py # Главный файл для запуска бота ├── config.py # Файл конфигурации
Конечно, вот краткое описание указанной части структуры проекта:

.venv: Виртуальная среда для Python, где установлены все зависимости и библиотеки для проекта.

api: Директория для API:

news_api.py: Модуль для взаимодействия с новостными API
(import os
import requests
from typing import List, Optional
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_news(query: Optional[str] = None, from_date: Optional[str] = None) -> List[str]:
    """
    Получает новости по ключевым словам и дате.
    :param query: Ключевые слова для поиска.
    :param from_date: Дата в формате YYYY-MM-DD.
    :return: Список новостей.
    """
    url = 'https://newsapi.org/v2/top-headlines'
    params = {
        'apiKey': os.getenv('NEWS_API_KEY'),  # Используем переменную окружения
        'pageSize': 5,  # Ограничиваем количество новостей
        'q': query,  # Поиск по ключевым словам
        'from': from_date  # Фильтрация по дате
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Проверка на ошибки HTTP
        data = response.json()

        if data['status'] != 'ok' or not data['articles']:
            logger.warning("Новости не найдены или API вернул пустой ответ.")
            return ["Новости не найдены."]

        news = []
        for article in data['articles']:
            news.append(f"{article['title']}\n{article['url']}")

        return news

    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при запросе к News API: {e}")
        return ["Не удалось получить новости. Пожалуйста, попробуйте позже."]).

photo_api.py: Модуль для взаимодействия с API фотографий
(import os
import requests
from typing import List
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def search_photos(query: str, max_results: int = 3) -> List[str]:
    """
    Ищет фото на Unsplash по ключевым словам.
    :param query: Ключевые слова для поиска.
    :param max_results: Максимальное количество результатов.
    :return: Список URL фотографий.
    """
    url = "https://api.unsplash.com/search/photos"
    headers = {"Authorization": f"Client-ID {os.getenv('UNSPLASH_API_KEY')}"}
    params = {"query": query, "per_page": max_results}

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()  # Проверка на ошибки HTTP
        data = response.json()

        if data["total"] == 0:
            logger.warning("Фото не найдены.")
            return ["Фото по вашему запросу не найдены."]

        photos = []
        for photo in data["results"]:
            photos.append(photo["urls"]["regular"])

        return photos

    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при запросе к Unsplash API: {e}")
        return ["Не удалось получить фото. Пожалуйста, попробуйте позже."]).

video_api.py: Модуль для взаимодействия с API видео
(import os
import requests
from typing import List
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def search_videos(query: str, max_results: int = 3) -> List[str]:
    """
    Ищет видео на YouTube по ключевым словам.
    :param query: Ключевые слова для поиска.
    :param max_results: Максимальное количество результатов.
    :return: Список ссылок на видео.
    """
    url = "https://www.googleapis.com/youtube/v3/search"
    params = {
        'key': os.getenv('YOUTUBE_API_KEY'),
        'part': 'snippet',
        'q': query,
        'maxResults': max_results,
        'type': 'video'
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Проверка на ошибки HTTP
        data = response.json()

        if not data.get('items'):
            logger.warning("Видео не найдены.")
            return ["Видео по вашему запросу не найдены."]

        videos = []
        for item in data['items']:
            video_id = item['id']['videoId']
            video_url = f"https://www.youtube.com/watch?v={video_id}"
            videos.append(video_url)

        return videos

    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при запросе к YouTube API: {e}")
        return ["Не удалось получить видео. Пожалуйста, попробуйте позже."]).

handlers: Директория для обработчиков:

news.py: Обработка новостных запросов
(from aiogram import Router, types, Dispatcher
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from api.news_api import get_news

router = Router()


# Обработчик для новостей
@router.message(lambda message: message.text == "Новости")
async def handle_news(message: types.Message):
    await message.answer("Введите ключевые слова для поиска новостей:")


# Обработчик текстового запроса для новостей
@router.message()
async def search_news(message: types.Message):
    query = message.text
    news = get_news(query=query)

    if not news:
        await message.answer("Новости не найдены.")
        return

    for item in news:
        await message.answer(item)

    # Кнопки для продолжения или возврата в меню
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="Вернуться в меню"), KeyboardButton(text="Продолжить поиск")]
        ],
        resize_keyboard=True
    )
    await message.answer("Что дальше?", reply_markup=keyboard)


# Регистрация обработчиков
def register_handlers_news(dp: Dispatcher):
    dp.include_router(router)).

photo.py: Обработка фотографий
(from aiogram import Router, types, Dispatcher
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from api.photo_api import search_photos

router = Router()


# Обработчик для фото
@router.message(lambda message: message.text == "Фото")
async def handle_photo(message: types.Message):
    await message.answer("Введите ключевые слова для поиска фото:")


# Обработчик текстового запроса для фото
@router.message()
async def search_photo(message: types.Message):
    query = message.text
    photos = search_photos(query=query)

    if not photos:
        await message.answer("Фото не найдены.")
        return

    for photo_url in photos:
        await message.answer_photo(photo=photo_url)

    # Кнопки для продолжения или возврата в меню
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="Вернуться в меню"), KeyboardButton(text="Продолжить поиск")]
        ],
        resize_keyboard=True
    )
    await message.answer("Что дальше?", reply_markup=keyboard)


# Регистрация обработчиков
def register_handlers_photo(dp: Dispatcher):
    dp.include_router(router)).

video.py: Обработка запросов на видео
(from aiogram import Router, types, Dispatcher
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from api.video_api import search_videos

router = Router()


# Обработчик для видео
@router.message(lambda message: message.text == "Видео")
async def handle_video(message: types.Message):
    await message.answer("Введите ключевые слова для поиска видео:")


# Обработчик текстового запроса для видео
@router.message()
async def search_video(message: types.Message):
    query = message.text
    videos = search_videos(query=query)

    if not videos:
        await message.answer("Видео не найдены.")
        return

    for video in videos:
        await message.answer(video)

    # Кнопки для продолжения или возврата в меню
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="Вернуться в меню"), KeyboardButton(text="Продолжить поиск")]
        ],
        resize_keyboard=True
    )
    await message.answer("Что дальше?", reply_markup=keyboard)


# Регистрация обработчиков
def register_handlers_video(dp: Dispatcher):
    dp.include_router(router)).

start.py: Обработка команды старта
(from aiogram import types, Dispatcher
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

# Обработчик команды /start
async def start(message: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="Новости", callback_data="news"),
            InlineKeyboardButton(text="Видео", callback_data="video"),
            InlineKeyboardButton(text="Фото", callback_data="photo")
        ]
    ])
    await message.answer(
        f"Привет, {message.from_user.first_name}! Выбери категорию:",
        reply_markup=keyboard
    )

# Обработчик для inline-кнопок
async def handle_category_callback(callback: types.CallbackQuery):
    category = callback.data
    await callback.answer(f"Вы выбрали: {category}")
    await callback.message.answer(f"Вы выбрали категорию: {category}. Введите запрос для поиска.")

# Регистрация обработчиков
def register_handlers_start(dp: Dispatcher):
    dp.message.register(start, Command(commands=["start"]))
    dp.callback_query.register(handle_category_callback, lambda c: c.data in ["news", "video", "photo"])).


bot.py
(import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from config import TELEGRAM_API_TOKEN
from handlers.start import register_handlers_start
from handlers.news import register_handlers_news
from handlers.video import register_handlers_video
from handlers.photo import register_handlers_photo



# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)

# Инициализация бота и диспетчера
bot = Bot(token=TELEGRAM_API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# Регистрация всех обработчиков
def register_all_handlers(dp: Dispatcher):
    register_handlers_start(dp)
    register_handlers_news(dp)
    register_handlers_video(dp)
    register_handlers_photo(dp)

async def main():
    logging.info("Запуск бота...")
    register_all_handlers(dp)  # Регистрируем все обработчики
    await dp.start_polling(bot)
    logging.info("Бот остановлен.")

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except Exception as e:
        logging.error(f"Ошибка при запуске бота: {e}")): Главный файл для создания и запуска бота.

config.py: Файл конфигурации, содержащий настройки и параметры для проекта, включая токен Telegram API
(import os
from dotenv import load_dotenv

# Загрузка переменных окружения из файла .env
load_dotenv()

# Токен Telegram бота
TELEGRAM_API_TOKEN = os.getenv('TELEGRAM_API_TOKEN')

# Ключи API для новостей, фото и видео
NEWS_API_KEY = os.getenv('NEWS_API_KEY')
UNSPLASH_API_KEY = os.getenv('UNSPLASH_API_KEY')
YOUTUBE_API_KEY = os.getenv('YOUTUBE_API_KEY')

# Настройки базы данных SQLite
# DATABASE_URL = "sqlite:///database.db").
.env: Файл окружения, содержащий конфиденциальные данные, такие как токены API.


